// Copyright 2025 AutoPDF BuddhiLW
// SPDX-License-Identifier: Apache-2.0

package integration

import (
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/BuddhiLW/AutoPDF/internal/autopdf/application"
	"github.com/BuddhiLW/AutoPDF/internal/autopdf/domain"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestSOLIDDDDIntegration tests the full SOLID + DDD + GoF architecture
// with real templates and configurations
func TestSOLIDDDDIntegration(t *testing.T) {
	// Get the service factory (Dependency Injection)
	factory := application.GetDefaultFactory()
	buildService := factory.GetBuildService()
	configService := factory.GetConfigurationService()

	ctx := context.Background()

	t.Run("SimpleSampleTemplate", func(t *testing.T) {
		// Create temp directory for output
		tempDir, err := os.MkdirTemp("", "autopdf-integration-*")
		require.NoError(t, err)
		defer os.RemoveAll(tempDir)

		// Get absolute paths
		templatePath, _ := filepath.Abs("../../templates/sample-template.tex")
		outputPath := filepath.Join(tempDir, "sample-output.pdf")

		// Create configuration directly (bypass YAML loading to avoid path issues)
		variables := map[string]interface{}{
			"title":   "Sample Document",
			"author":  "John Doe",
			"date":    "April 1, 2025",
			"content": "This is a sample document generated by AutoPDF.",
		}

		// Build the PDF
		result, err := buildService.BuildPDF(ctx, &domain.BuildRequest{
			TemplatePath: templatePath,
			OutputPath:   outputPath,
			Variables:    variables,
			ShouldClean:  true,
		})

		require.NoError(t, err)
		assert.NotNil(t, result)
		assert.True(t, result.Success)

		// Verify PDF was created
		_, err = os.Stat(result.PDFPath)
		assert.NoError(t, err)

		// Verify PDF has content
		pdfBytes, err := os.ReadFile(result.PDFPath)
		require.NoError(t, err)
		assert.Greater(t, len(pdfBytes), 0)
		assert.Equal(t, "%PDF-", string(pdfBytes[0:5]))

		t.Logf("‚úÖ Simple sample template built successfully in %v", result.BuildTime)
	})

	t.Run("EnhancedComplexTemplate", func(t *testing.T) {
		// Create temp directory for output
		tempDir, err := os.MkdirTemp("", "autopdf-integration-*")
		require.NoError(t, err)
		defer os.RemoveAll(tempDir)

		// Get absolute paths
		templatePath, _ := filepath.Abs("../../templates/enhanced-document.tex")
		configPath, _ := filepath.Abs("../../configs/enhanced-sample-config.yaml")

		// Load the enhanced configuration
		cfg, err := configService.LoadConfiguration(ctx, configPath)
		require.NoError(t, err)

		// Override paths to absolute
		cfg.Template = templatePath
		cfg.Output = filepath.Join(tempDir, "enhanced-output.pdf")

		// Build the PDF
		result, err := buildService.BuildPDF(ctx, &domain.BuildRequest{
			TemplatePath: templatePath,
			ConfigPath:   configPath,
			OutputPath:   cfg.Output,
			Variables:    cfg.Variables,
			ShouldClean:  true,
		})

		require.NoError(t, err)
		assert.NotNil(t, result)
		assert.True(t, result.Success)

		// Verify PDF was created
		_, err = os.Stat(result.PDFPath)
		assert.NoError(t, err)

		// Verify PDF has content
		pdfBytes, err := os.ReadFile(result.PDFPath)
		require.NoError(t, err)
		assert.Greater(t, len(pdfBytes), 0)
		assert.Equal(t, "%PDF-", string(pdfBytes[0:5]))

		t.Logf("‚úÖ Enhanced complex template built successfully in %v", result.BuildTime)
		t.Logf("   Template demonstrated: nested objects, arrays, loops, complex data structures")
	})

	t.Run("TestDataComplexConfig", func(t *testing.T) {
		// Create temp directory for output
		tempDir, err := os.MkdirTemp("", "autopdf-integration-*")
		require.NoError(t, err)
		defer os.RemoveAll(tempDir)

		// Get absolute paths
		templatePath, _ := filepath.Abs("../../internal/autopdf/test-data/complex_template.tex")
		configPath, _ := filepath.Abs("../../internal/autopdf/test-data/complex_config.yaml")

		// Load the test data complex configuration
		cfg, err := configService.LoadConfiguration(ctx, configPath)
		require.NoError(t, err)

		// Override paths to absolute
		cfg.Template = templatePath
		cfg.Output = filepath.Join(tempDir, "complex-output.pdf")

		// Build the PDF
		result, err := buildService.BuildPDF(ctx, &domain.BuildRequest{
			TemplatePath: templatePath,
			ConfigPath:   configPath,
			OutputPath:   cfg.Output,
			Variables:    cfg.Variables,
			ShouldClean:  true,
		})

		require.NoError(t, err)
		assert.NotNil(t, result)
		assert.True(t, result.Success)

		// Verify PDF was created
		_, err = os.Stat(result.PDFPath)
		assert.NoError(t, err)

		t.Logf("‚úÖ Test data complex config built successfully in %v", result.BuildTime)
	})
}

// TestConversionIntegration tests the conversion service with Strategy Pattern
func TestConversionIntegration(t *testing.T) {
	factory := application.GetDefaultFactory()
	buildService := factory.GetBuildService()
	conversionService := factory.GetConversionService()
	configService := factory.GetConfigurationService()

	ctx := context.Background()

	t.Run("BuildWithConversion", func(t *testing.T) {
		// Create temp directory for output
		tempDir, err := os.MkdirTemp("", "autopdf-conversion-*")
		require.NoError(t, err)
		defer os.RemoveAll(tempDir)

		// Get absolute paths
		templatePath, _ := filepath.Abs("../../templates/sample-template.tex")
		configPath, _ := filepath.Abs("../../configs/sample-config.yaml")

		// Load configuration
		cfg, err := configService.LoadConfiguration(ctx, configPath)
		require.NoError(t, err)

		// Override paths and enable conversion
		cfg.Template = templatePath
		cfg.Conversion.Enabled = true
		cfg.Conversion.Formats = []string{"png"}
		cfg.Output = filepath.Join(tempDir, "converted-output.pdf")

		// Build the PDF
		result, err := buildService.BuildPDF(ctx, &domain.BuildRequest{
			TemplatePath: templatePath,
			ConfigPath:   configPath,
			OutputPath:   cfg.Output,
			Variables:    cfg.Variables,
			ShouldClean:  true,
		})

		// Note: Conversion might fail if ImageMagick/Poppler not installed
		// That's okay - we're testing the architecture, not the external tools
		if err != nil {
			t.Logf("‚ö†Ô∏è  Conversion failed (external tools may not be installed): %v", err)
			t.Skip("Skipping conversion test - external tools not available")
		}

		assert.NotNil(t, result)
		t.Logf("‚úÖ Build with conversion completed in %v", result.BuildTime)

		if len(result.ImagePaths) > 0 {
			t.Logf("   Generated images: %v", result.ImagePaths)
		}
	})

	t.Run("DirectConversion", func(t *testing.T) {
		// Create temp directory for output
		tempDir, err := os.MkdirTemp("", "autopdf-conversion-*")
		require.NoError(t, err)
		defer os.RemoveAll(tempDir)

		// Get absolute paths
		templatePath, _ := filepath.Abs("../../templates/sample-template.tex")
		configPath, _ := filepath.Abs("../../configs/sample-config.yaml")

		// First build a PDF
		cfg, err := configService.LoadConfiguration(ctx, configPath)
		require.NoError(t, err)

		cfg.Template = templatePath
		cfg.Output = filepath.Join(tempDir, "for-conversion.pdf")

		result, err := buildService.BuildPDF(ctx, &domain.BuildRequest{
			TemplatePath: templatePath,
			OutputPath:   cfg.Output,
			Variables:    cfg.Variables,
			ShouldClean:  false,
		})
		require.NoError(t, err)

		// Now convert it
		imagePaths, err := conversionService.ConvertPDFToImages(ctx, result.PDFPath, []string{"png"})

		// Again, might fail if tools not installed
		if err != nil {
			t.Logf("‚ö†Ô∏è  Direct conversion failed (external tools may not be installed): %v", err)
			t.Skip("Skipping direct conversion test - external tools not available")
		}

		assert.NotEmpty(t, imagePaths)
		t.Logf("‚úÖ Direct conversion successful: %v", imagePaths)
	})
}

// TestFactoryPatterns tests the Factory Pattern implementations
func TestFactoryPatterns(t *testing.T) {
	t.Run("TemplateEngineFactory", func(t *testing.T) {
		factory := domain.NewTemplateEngineFactory()

		// Test LaTeX engine creation
		engine, err := factory.CreateEngine("latex")
		require.NoError(t, err)
		assert.NotNil(t, engine)
		assert.Equal(t, "latex", engine.GetName())

		// Test available engines
		engines := factory.GetAvailableEngines()
		assert.Contains(t, engines, "latex")

		t.Logf("‚úÖ Template Engine Factory: %v engines available", len(engines))
	})

	t.Run("PDFEngineFactory", func(t *testing.T) {
		factory := domain.NewPDFEngineFactory()

		// Test pdflatex engine creation
		engine, err := factory.CreateEngine("pdflatex")
		require.NoError(t, err)
		assert.NotNil(t, engine)
		assert.Equal(t, "pdflatex", engine.GetName())

		// Test xelatex engine creation
		engine, err = factory.CreateEngine("xelatex")
		require.NoError(t, err)
		assert.NotNil(t, engine)
		assert.Equal(t, "xelatex", engine.GetName())

		// Test available engines
		engines := factory.GetAvailableEngines()
		assert.Contains(t, engines, "pdflatex")
		assert.Contains(t, engines, "xelatex")

		t.Logf("‚úÖ PDF Engine Factory: %v engines available", len(engines))
	})

	t.Run("ConversionEngineFactory", func(t *testing.T) {
		factory := domain.NewConversionEngineFactory()

		// Test ImageMagick engine creation
		engine, err := factory.CreateEngine("imagemagick")
		require.NoError(t, err)
		assert.NotNil(t, engine)

		// Test Poppler engine creation
		engine, err = factory.CreateEngine("poppler")
		require.NoError(t, err)
		assert.NotNil(t, engine)

		// Test available engines
		engines := factory.GetAvailableEngines()
		assert.Contains(t, engines, "imagemagick")
		assert.Contains(t, engines, "poppler")

		t.Logf("‚úÖ Conversion Engine Factory: %v engines available", len(engines))
	})
}

// TestEventDrivenArchitecture tests the Observer Pattern implementation
func TestEventDrivenArchitecture(t *testing.T) {
	t.Run("EventPublishing", func(t *testing.T) {
		publisher := domain.NewEventPublisher()

		// Create a simple event handler
		eventReceived := false
		handler := &testEventHandler{
			handleFunc: func(event domain.Event) error {
				eventReceived = true
				t.Logf("üì¢ Event received: %s at %v", event.GetEventType(), event.GetTimestamp())
				return nil
			},
		}

		// Subscribe to events
		err := publisher.Subscribe("test.event", handler)
		require.NoError(t, err)

		// Publish an event
		event := domain.NewDomainEvent("test.event", map[string]interface{}{
			"message": "Testing event-driven architecture",
		})

		err = publisher.Publish(event)
		require.NoError(t, err)
		assert.True(t, eventReceived)

		t.Logf("‚úÖ Event-driven architecture working correctly")
	})
}

// testEventHandler is a simple event handler for testing
type testEventHandler struct {
	handleFunc func(event domain.Event) error
}

func (h *testEventHandler) Handle(event domain.Event) error {
	return h.handleFunc(event)
}
